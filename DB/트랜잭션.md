# 트랜잭션(Transaction)
* 트랜잭션이란 "여러 DB 작업을 하나의 원자적 단위로 묶어 성공하면 전부 반영(Commit), 실패하면 전부 취소(Rollback)"하게 만드는 장치
    * 데이터의 무결성, 안정성을 보장하는 가장 핵심적인 안전장치

<br>
<br>

## 1. "All or Nothing"
* 모두 성공하거나, 모두 실패해야 하는 논리적인 작업 단위
* 예시: 계좌 이체

```markdown
# 두 작업은 하나의 묶음, 즉 하나의 트랜잭션으로 처리되어야 함
1. A의 계좌에서 10,000원을 차감한다
2. B의 계좌에 10,000원을 증가시킨다

# 만약 트랜잭션이 없다면
* 1번 작업(차감)은 성공했는데, 바로 그 순간 시스템이 멈추거나 오류 발생하여 2번 작업(증가)이 실패한 경우
* 결과: A의 돈은 사라졌으나, B에게 들어오지 않음. 데이터가 깨진 상태(inconsistent)가 됨

# 트랜잭션이 있다면
* 두 작업을 하나의 트랜잭션으로 묶으면, 1번과 2번이 모두 성공해야만 최종적으로 데이터베이스에 COMMIT (확정) 됨
* 중간에 하나라도 실패하면, 시스템은 ROLLBACK (취소)을 실행하여 1번 작업마저 없었던 일로 되돌림. A의 계좌는 원래대로 복구
* 따라서 데이터는 항상 안전하고 일관된 상태를 유지함
```

<br>
<br>
<br>
<br>

## 2. ACID 원칙
* **Atomicity** : 전부 되거나 전부 안 되거나 (반쪽 성공 방지)
* **Consistency** : 비즈니스/제약조건을 깨지 않음
* **Isolation** : 동시에 실행돼도 서로 간섭 최소화 (더티리드/팬텀 등 방지)
* **Durability** : 커밋된 내용은 장애 후에도 보존

<br>
<br>
<br>
<br>

## 3. ORM에서 트랜잭션이 더 중요한 이유
* ORM은 내부적으로 우리가 작성한 코드를 여러 개의 SQL 문으로 변환함
* 예를 들어 사용자가 회원가입을 하고, 기본 프로필을 생성하는 코드를 ORM으로 작성했다고 가정

```python
# 이 코드는 내부적으로 여러 SQL을 실행할 수 있습니다.
new_user = User(name="홍길동")
new_profile = Profile(user=new_user, status="활성")

session.add(new_user)
session.add(new_profile)

session.commit() # <- 이 시점에 트랜잭션이 확정됩니다.
```

* 위 코드는 내부적으로 다음과 같은 여러 SQL 실행할 수 있음

```sql
INSERT INTO users ...
INSERT INTO profiles ...
(경우에 따라) UPDATE users ...
```

* 만약 `users` 테이블에 저장이 성공했는데, `profiles` 테이블 저장에서 오류가 발생한다면?
* 트랜잭션이 없었다면 `users` 테이블에만 데이터가 남는 "유령회원"이 생길 것임

<br>

### 3.1. SQLAlchemy의 `Session` 객체
* `Session` 객체는 그 자체가 하나의 트랜잭션 범위처럼 동작하도록 설계 됨
* `session.add(객체)`: 변경사항을 데이터베이스에 바로 보내는 것이 아닌, "이런 변경을 할 것이다"라고 세션에 등록만 함 (작업을 모으는 단계)
* `session.commit()`: 세션에 등록된 모든 변경사항(`INSERT`, `UPDATE`, `DELETE` 등)을 하나의 트랜잭션으로 묶어 데이터베이스에 전송하고 확정함.
    * 하나라도 실패하면 모든 작업이 `ROLLBACK` 됨
* `session.rollback()`: 세션에 등록된 모든 변경사항 취소

<br>

### 3.2. 트랜잭션을 반드시 써야 하는 순간
* 다단계 작업(예: 주문 생성 → 결제 기록 → 재고 차감)
* 여러 테이블 동시 갱신
* 에러가 나면 전부 되돌려야 하는 로직
* 동시성 많은 환경(웹 서비스)에서 정합성 보장

<br>
<br>
<br>
<br>

## 4. Session

* SQLAlchemy의 `Session`: ORM의 작업 공간
    * 데이터베이스 작업을 위한 임시 작업 공간 (Workspace)

    * ORM을 통해 데이터베이스와 상호작용하는 모든 작업은 Session을 통해 이루어짐

    * Session은 트랜잭션을 담는 컨테이너로, 하나의 Session 안에서도 `ses.begin()`으로 여러 트랜잭션을 순차료 열고 닫을 수 있음(autobegin으로 자동 시작)

* DB 커넥션은 필요할 때 풀에서 빌려오고, 사용 후 반환
    * 변경은 commit 시점에 하나의 트랜잭션으로 반영, 실패 시 롤백

* Session 비유 (온라인 쇼핑의 장바구니)
    * 물건을 장바구니에 담고 (`session.add`)

    * 수량을 바꾸고 (객체 속성 변경)
    * 장바구니에서 빼는 작업 (`session.delete`) 등의 작업을 함
    * 이 모든 작업은 '결제하기' (`session.commit`) 버튼을 누르기 전까지는 실제 상점(DB)에 아무런 영향을 주지 않음
    * 만약 결제 중간에 마음이 바뀌어서 취소하면 (`session.rollback`), 장바구니의 모든 변경사항은 없었던 일이 됨

<br>
<br>

### 4.1. `Session`의 주요 역할
1. 작업 단위 (Unit of Work)
    * `Session`의 가장 핵심적인 역할
    * 개발자가 수행하는 여러 변경 작업(추가, 수정, 삭제)을 하나의 논리적인 트랜잭션 단위로 관리
    * `session.commit()`이 호출되기 전까지 모든 변경사항을 메모리상에만 유지하다가, 호출되는 순간 모든 변경사항을 하나의 트랜잭션으로 묶어 DB에 전송

<br>

2. 신원 맵(Identity Map)
    * `Session` 내에서 객체의 유일성을 보장하는 매우 중요한 기능
    * 한 `Session` 안에서 특정 PK(Primary Key)를 가진 객체는 단 하나만 존재
    * 예를 들어, `id=5`인 사용자를 한 세션에서 두 번 조회해도, SQLAlchemy는 DB에 두번 접근하는 대신, 처음 조회했던 바로 그 동일한 파이썬 객체를 반환해 줌
    * 이를 통해 메모리상 데이터가 꼬이는 것을 방지하고 일관성 유지

<br>

3. 데이터베이스 연결 관리
    * `Session`은 `Engine`으로부터 DB 커넥션을 빌려와서 자신의 작업(쿼리, 커밋 등)을 수행
    * 작업이 끝나고 `session.close()`가 호출되면, 빌렸던 커넥션을 다시 `Engine`의 커넥션 풀(pool)에 반환하여 다른 `Session`이 재사용할 수 있도록 함

<br>


4. 쿼리 실행
    * `session.execute(select(...))`와 같이, DB에 데이터를 조회하는 쿼리를 생성하고 실행하는 시작점 역할을 함

<br>
<br>

### 4.2. `Session`의 생명주기 (Lifecycle)
* 일반적으로 `Session`은 다음과 같은 생명주기를 가짐

```python
# SessionLocal은 sessionmaker로 미리 만들어 둔 세션 생성 팩토리
session = SessionLocal()
try:
    # 1. 조회: DB에서 객체를 불러와 Session의 Identity Map에 등록
    my_user = session.get(User, 1)

    # 2. 변경: 객체의 속성을 바꾸거나, 새로운 객체를 add하거나 delete
    my_user.name = "새이름"
    session.add(new_order)

    # 3. 커밋: Session에 기록된 모든 변경사항을 DB에 하나의 트랜잭션으로 전송
    session.commit()

except Exception:
    
    # 4. 롤백: 오류 발생 시, 지금까지의 모든 변경사항을 취소
    session.rollback()
    raise # 오류는 상위로 다시 전달

finally:
    # 5. 닫기: 성공하든 실패하든, 작업이 끝나면 반드시 세션을 닫아 커넥션 반환
    session.close()
```

* FastAPI 같은 웹 프레임워크에서는 이 `try...except...finally` 구조를 `Depends`를 통해 자동화함

<br>
<br>

### 4.3. `Sessionmaker` - 세션 팩토리
* `sessionmaker`란?
    * Session 객체를 만들어내는 '공장(Factory)' 입니다.
    * 애플리케이션 전체에서 사용할 세션의 기본 설정을 미리 구성해두는 역할을
        합니다.
    * bind=engine (어떤 DB 엔진에 연결할지), expire_on_commit (커밋 정책),
        autoflush (자동 flush 여부) 등 모든 Session이 공통으로 가질 설정을 한곳에서
        관리할 수 있게 해줍니다.
    * 이렇게 만들어진 SessionLocal()을 호출할 때마다, 미리 설정된 값들을 가진
        새로운 Session 인스턴스가 생성됩니다.

<br>
<br>

### 4.4. 베스트 패턴
* 동기
```python
from sqlalchemy.orm import Session, sessionmaker

SessionLocal = sessionmaker(bind=engine, expire_on_commit=False)

# 한 요청 = 한 트랜잭션
with SessionLocal() as ses, ses.begin():      # 성공 → commit, 예외 → rollback 자동
    # ses.add(...); ses.execute(...); ses.query(...)
    ...
```
* 이 구문은 두 개의 with 문을 합친 것입니다.
    1. `with SessionLocal() as ses:`: 세션의 생명주기를 관리합니다. 이 블록이
        끝나면 `ses.close()`가 자동으로 호출되어 커넥션이 풀에 반환됩니다.
        `try...finally`에서 `session.close()`를 직접 호출하는 것보다 안전하고
        간결합니다.
    2. `... as ses, ses.begin():`: 트랜잭션의 생명주기를 관리합니다. 이 블록이
        시작될 때 트랜잭션이 시작(BEGIN)되고, 블록이 오류 없이 성공적으로 끝나면
        자동으로 `COMMIT` 됩니다. 만약 블록 내에서 예외가 발생하면 자동으로
        `ROLLBACK` 됩니다. `try...except`에서 `commit`/`rollback`을 직접 호출하는 것보다
        훨씬 안전합니다.

* `expire_on_commit=False`: 커밋 직후에도 객체 속성 접근 시 재조회(리로드) 방지 → 사용성↑
    * "웹 애플리케이션에서는 보통 데이터를 `COMMIT`한 직후, 그 객체를 JSON으로 변환하여
     클라이언트에게 반환하는 경우가 많습니다. 이때 `expire_on_commit=True`(기본값)이면,
      커밋 후 객체의 모든 속성이 만료되어 JSON 변환 시 객체 속성에 접근하는 순간
     추가적인 `SELECT` 쿼리가 발생합니다. `False`로 설정하면 이 불필요한 재조회를 막아
     성능을 높일 수 있습니다."

* 트랜잭션은 짧게 유지

<br>

* 비동기
```python
from sqlalchemy.ext.asyncio import async_sessionmaker, AsyncSession

AsyncSessionLocal = async_sessionmaker(bind=async_engine, expire_on_commit=False)

async with AsyncSessionLocal() as ses, ses.begin():
    # await ses.execute(...); ses.add(...)
    ...
```

<br>
<br>

### 4.5. flush vs commit
* flush: SQL을 DB에 임시 반영 (트랜잭션 열려있음 → 롤백 가능)

* commit: 트랜잭션 확정

* ORM은 쿼리 실행 직전 자동 flush 될 수 있음 (기본 autoflush=True)

* 같은 트랜잭션에서 PK가 필요하면:

```python
ses.add(obj)
ses.flush()           # 여기서 PK 생성됨
print(obj.id)         # 바로 사용 가능
```

<br>
<br>

### 4.6. 격리 수준(필요 시)
* 기본: READ COMMITTED

* 강하게: REPEATABLE READ / SERIALIZABLE

```python
# 엔진 수준
engine = create_engine(..., isolation_level="REPEATABLE READ")
# 트랜잭션 내부에서 동적으로
await ses.execute(text("SET TRANSACTION ISOLATION LEVEL SERIALIZABLE"))
```

<br>
<br>

### 4.7. 세이브포인트(부분 되돌리기)

```python
with SessionLocal() as ses, ses.begin():
    sp = ses.begin_nested()   # SAVEPOINT
    try:
        ...
        sp.commit()
    except:
        sp.rollback()         # 해당 구간만 취소
```

<br>
<br>

### 4.8. 잠금과 동시성
* 비관적 락(갱신 충돌 회피)

```python
from sqlalchemy import select

with SessionLocal() as ses, ses.begin():
    row = ses.execute(
        select(User).where(User.id == 1).with_for_update()
    ).scalar_one()
    row.name = "lock-update"
```

* 낙관적 락(권장): 버전 칼럼으로 충돌 감지
```python
from sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column

class Base(DeclarativeBase): pass

class User(Base):
    __tablename__ = "users"
    id: Mapped[int] = mapped_column(primary_key=True)
    version_id: Mapped[int] = mapped_column(nullable=False, default=0)
    __mapper_args__ = {"version_id_col": version_id}  # 충돌 시 StaleDataError
```

   1. 사용자 A가 id=1, version_id=5인 게시물을 조회합니다.

   2. 사용자 B도 동시에 id=1, version_id=5인 게시물을 조회합니다.
   3. 사용자 B가 게시물을 수정하고 COMMIT합니다. DB에는 UPDATE ... WHERE id=1 AND
      version_id=5 쿼리가 실행됩니다. 성공적으로 반영되고, DB의 version_id는 6으로
      변경됩니다.
   4. 이제 사용자 A가 게시물을 수정하고 COMMIT합니다. SQLAlchemy는 똑같이 UPDATE ...
      WHERE id=1 AND version_id=5 쿼리를 실행합니다.
   5. 하지만 DB의 version_id는 이미 6이므로, 이 UPDATE 쿼리는 아무런 행도 변경하지
      못합니다(0 rows affected).
   6. SQLAlchemy는 1개의 행이 변경될 것으로 예상했지만 0개가 변경된 것을 감지하고,
      "내가 조회한 이후 누군가 데이터를 수정했다"고 판단하여 StaleDataError를
      발생시킵니다.
   7. 개발자는 이 예외를 잡아서 사용자 A에게 "데이터가 변경되었으니 새로고침 후 다시
      시도해 주세요"와 같은 메시지를 보여줄 수 있습니다.

<br>
<br>

### 4.9. 세션 스코프 & 금지 패턴
* 한 요청(작업) 당 하나의 Session 생성/종료 (스레드 세이프 아님)

* 금지: 글로벌 싱글톤 세션 / 장시간(분~시간) 열린 세션 / 요청 간 재사용 / sync & async 혼용

<br>
<br>

### 4.10. FastAPI 연동 (요청 스코프)
* 동기

```python
from fastapi import Depends

SessionLocal = sessionmaker(bind=engine, expire_on_commit=False)

def get_session():
    with SessionLocal() as ses, ses.begin():
        yield ses   # 요청 처리 후 자동 commit/rollback

@app.post("/users")
def create_user(dto: UserIn, ses: Session = Depends(get_session)):
    u = User(name=dto.name)
    ses.add(u)
    ses.flush()          # ← PK 채번 보장
    return {"id": u.id}
```

<br>

* 비동기
```python
from fastapi import Depends
from sqlalchemy.ext.asyncio import async_sessionmaker, AsyncSession

AsyncSessionLocal = async_sessionmaker(bind=async_engine, expire_on_commit=False)

async def get_session():
    async with AsyncSessionLocal() as ses, ses.begin():
        u = User(name=dto.name)
        ses.add(u)
        await ses.flush()
        return {"id": u.id}

@app.post("/users")
async def create_user(dto: UserIn, ses: AsyncSession = Depends(get_session)):
    ...
```
