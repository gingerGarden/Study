# FastAPI
* 빠름: Starlette + Pydantic에 의해 NodeJS, Go와 대등할 정도로 빠름
* 타입 검증: Python 타입 힌트를 활용한 자동 데이터 검증
* 문서화 자동 생성: Swagger UI와 ReDoc을 자동 제공
* 비동기 지원: `async`/`await` 지원으로 높은 동시성 처리

<br>
<br>
<br>
<br>

# 1. FastAPI가 빠른 이유: `Starlette` + `Pydantic`
* Python 기반 웹프레임워크가 Node.js와 Go와 대등할 정도로 빠른 이유

<br>
<br>

## A. Starlette = 초경량 비동기 프레임워크
* FastAPI의 HTTP 요청 처리 엔진: **Starlette**

* FastAPI의 기반 웹서버

* 매우 경량(약 5k LOC)이고 빠름
> * Starlette 자체가 매우 얆은 추상화 계층 - 의존성 최소화
> * 불필요한 오버헤드 없음

* Python의 async/await 비동기 I/O 풀 지원
> * Python의 `asyncio`를 100% 활용
> * 많은 요청을 한꺼번에 처리 가능 (Flask는 동기 방식이라 처리량 낮음)

* ASGI (Asynchronous Server Gateway Interface) 기반
> * WSFI(Flask, Django)보다 진보된 인터페이스

* WebSocket, HTTP2, Server-Sent Events(SSE) 같은 최신 프로토콜 지원

### 속도 비교 (참고 Benchmarks)

|Framework|요청 처리 속도(req/s)|
|---|---|
|FastAPI|~30,000|
|Node.js (Express)|~28,000|
|Go (Gin)|~35,000|
|Flask|~5,000|

<br>
<br>

## B. Pydantic = 초고속 데이터 검증기

* 데이터 파싱과 검증 담당

* JSON → Python 객체로 변환
* 타입 검사 및 유효성 검증
* 기본값, 형 변환, 필드 검증

### 빠른 이유
1. Cython 최적화
> * 내부에서 CPython/Cython으로 처리
> * Python의 순수 dict parsing보다 훨씬 빠른

2. 타입 힌트 사용
> * Python 타입 힌트를 활용해 동적 검증 로직 제거
> * 컴파일 타임에 데이터 유효성 규칙 준지

3. Lazy Validation
> * 요청이 올 때 필요한 만큼만 검증

### 예제: 데이터 파싱 속도

```python
from pydantic import BaseModel

class User(BaseModel):
    id: int
    name: str
    email: str

# id를 int로 자동 변환하고 검증까지 수행
u = User(id="1", name="Alice", email="alice@example.com")
```

* 위와 같은 변환을 Flask에서는 수동으로 해야 함
* Pydantic은 10배 이상 빠르게 처리 가능

<br>
<br>

## C. Pydantic 심화
* `Field` : 요청 데이터에서 각 필드의 제약 조건 정의
* `validator`로 커스텀 검증 : 한 필드 또는 여러 필드 간 검증 로직 추가 시 사용
* `Nested` 모델 (중첩 스키마) : 요청 JSON이 중첩된 구조인 경우, 모델 안에 모델로 처리

|기능|예제|설명|
|---|---|---|
|Field 옵션|`Field(..., gt=0, max_length=50)`|필드 단위 유효성 검증, Swagger 문서화 반영|
|@validator|커스텀 로직 구현|한 필드 또는 여러 필드 간 검증 로직 추가|
|Nested 모델|모델 안에 모델 정의|중첩 JSON 구조 대응|

<br>

### C-1. Field
* 매개변수

|옵션|설명|
|---|---|
|`...`|필수 필드 표시(required)|
|`title`|Swagger 문서에 필드 제목으로 표시|
|`description`|Swagger 문서에 필드 설명 추가|
|`max_length`|문자열 최대 길이|
|`gt`,`ge`|숫자 > (greater than), >= (greater equal)|
|`lt`,`le`|숫자 < (lower than), <= (lower equal)|
|`default`|기본값 지정|

* 예제 코드
```python
from fastapi import FastAPI
from pydantic import BaseModel, Field

app = FastAPI()

class Item(BaseModel):
    name: str = Field(..., title="아이템 이름", max_length=50)
    price: float = Field(..., gt=0, description="가격은 0보다 커야 함")
    quantity: int = Field(default=1, ge=1, le=100, description="1~100 사이")

@app.post("/items/")
def create_item(item: Item):
    return item
```

* 정상 요청
```json
POST /items/
{
    "name": "FastAPI 초보 탈출",
    "price": 9.99,
    "quantity": 10
}
```
* 잘못된 요청
```json
POST /items/
{
    "name": "이름이 매우매우매우매우매우매우 길다aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa",
    "price": -1,
    "quantity": 101
}
```
* 응답
```json
{
    "detail": [
        {"loc": ["body", "name"], "msg": "ensure this value has at most 50 characters", "type": "value_error.any_str.max_length"},
        {"loc": ["body", "price"], "msg": "ensure this value is greater than 0", "type": "value_error.number.not_gt"},
        {"loc": ["body", "quantity"], "msg": "ensure this value is less than or equal to 100", "type": "value_error.number.not_le"}
    ]
}
```

<br>

### C-2. `@validator`로 커스텀 검증
* 예제 코드
```python
from pydantic import BaseModel, validator

class User(BaseModel):
    username: str
    email: str

    @validator("email")
    def validate_email(cls, v):
        if "@" not in v:
            raise ValueError("유효하지 않은 이메일 형식입니다.")
        return v

@app.post("/users/")
def create_user(user: User):
    return user
```
* 정상 요청
```json
POST /users/
{
    "username": "junedev",
    "email": "june@example.com"
}
```
* 잘못된 요청
```json
POST /users/
{
    "username": "junedev",
    "email": "not-an-email"
}
```
* 응답
```json
{
    "detail": [
        {"loc": ["body", "email"], "msg": "유효하지 않은 이메일 형식입니다.", "type": "value_error"}
    ]
}
```
* 고급: 여러 필드 의존 검증
```python
class Product(BaseModel):
    price: float
    discount: float

    @validator("discount")
    def discount_must_be_less_than_price(cls, v, values):
        if "price" in values and v >= values["price"]:
            raise ValueError("할인은 가격보다 작아야 합니다.")
        return v
```

<br>

### C-3. Nested 모델 (중첩 스키마)
* 예제 코드
```python
class Address(BaseModel):
    street: str
    city: str
    zipcode: str = Field(..., regex="^\d{5}$")

class Order(BaseModel):
    item_name: str
    quantity: int = Field(..., gt=0)
    shipping_address: Address

@app.post("/orders/")
def create_order(order: Order):
    return order
```
* 정상 요청
```json
POST /orders/
{
    "item_name": "FastAPI 교재",
    "quantity": 2,
    "shipping_address": {
        "street": "중앙로 123",
        "city": "서울",
        "zipcode": "12345"
    }
}
```
* 잘못된 요청
```json
POST /orders/
{
    "item_name": "FastAPI 교재",
    "quantity": 0,
    "shipping_address": {
        "street": "중앙로 123",
        "city": "서울",
        "zipcode": "abcde"
    }
}
```
* 응답
```json
{
    "detail": [
        {"loc": ["body", "quantity"], "msg": "ensure this value is greater than 0", "type": "value_error.number.not_gt"},
        {"loc": ["body", "shipping_address", "zipcode"], "msg": "string does not match regex \"^\\d{5}$\"", "type": "value_error.str.regex"}
    ]
}
```


<br>
<br>

## D. 요약: Node.js / Go와 대등한 성능
* FastAPI = Starless(비동기) + Pydantic(데이터 검증)의 조합
* 단순 JSON API라면 Node.js, Go와 동급 처리량
* I/O bound 작업(DB, 외부 API 호출 등)에서 특히 강력
* 단점: Python 자체가 GIL 때문에 CPU bound 작업은 Go보다 느림

|요소|FastAPI|
|---|---|
|요청 처리 엔진|Starlette (ASGI 기반 초경량 비동기 프레임워크)|
|데이터 검증|Pydantic (Cython 최적화된 초고속 파서)|
|장점|Node.js/Go에 맞먹는 I/O 처리 성능|
|한계|CPU 연산 많을 땐 Go가 여전히 우위|

<br>
<br>

## E. FastAPI의 요청 처리 순서
```
클라이언트 요청
   ↓
ASGI 서버(Uvicorn)
   ↓
Starlette가 요청 처리
   ↓
FastAPI 라우터에서 경로 매칭
   ↓
Pydantic으로 요청 데이터 검증 & 파싱
   ↓
엔드포인트 함수 호출 (sync/async)
   ↓
Pydantic으로 응답 데이터 검증
   ↓
ASGI 서버가 응답 반환
```
* Pydantic이 요청/응답 검증 담당
* Starlette가 라우팅/미들웨어/비동기 처리 담당
> 요청의 모든 과정이 타입 안전 + 비동기 최적화 되어 있는 구조
