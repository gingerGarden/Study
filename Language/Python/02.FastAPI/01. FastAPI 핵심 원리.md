# FastAPI
* 빠름: Starlette + Pydantic에 의해 NodeJS, Go와 대등할 정도로 빠름
* 타입 검증: Python 타입 힌트를 활용한 자동 데이터 검증
* 문서화 자동 생성: Swagger UI와 ReDoc을 자동 제공
* 비동기 지원: `async`/`await` 지원으로 높은 동시성 처리

<br>
<br>
<br>
<br>

# 1. FastAPI가 빠른 이유: `Starlette` + `Pydantic`
* Python 기반 웹프레임워크가 Node.js와 Go와 대등할 정도로 빠른 이유

<br>
<br>
<br>
<br>

## A. Starlette = 초경량 비동기 프레임워크
* FastAPI의 HTTP 요청 처리 엔진: **Starlette**

* FastAPI의 기반 웹서버

* 매우 경량(약 5k LOC)이고 빠름
> * Starlette 자체가 매우 얆은 추상화 계층 - 의존성 최소화
> * 불필요한 오버헤드 없음

* Python의 async/await 비동기 I/O 풀 지원
> * Python의 `asyncio`를 100% 활용
> * 많은 요청을 한꺼번에 처리 가능 (Flask는 동기 방식이라 처리량 낮음)

* ASGI (Asynchronous Server Gateway Interface) 기반
> * WSFI(Flask, Django)보다 진보된 인터페이스

* WebSocket, HTTP2, Server-Sent Events(SSE) 같은 최신 프로토콜 지원

<br>
<br>

### A-1. Starlette와 Flask의 비동기/동기 처리 방식 비교

* Starlette (비동기: Non-blocking)
> * `asyncio.sleep(1)`로 1초 대기하는 동안 다른 요청 받을 수 있음

```python
# starlette_example.py
import asyncio
from starlette.applications import Starlette
from starlette.responses import JSONResponse
from starlette.routing import Route

async def homepage(request):
    await asyncio.sleep(1)  # I/O 작업을 비동기로 시뮬레이션
    return JSONResponse({'hello': 'world'})

routes = [
    Route("/", endpoint=homepage),
]

app = Starlette(debug=True, routes=routes)
```

<br>

* Flask (동기: Blocking)
> * `time.sleep(1)`으로 1초 대기하는 동안 다른 모든 요청이 대기 상태에 빠짐

```python
# flask_example.py
import time
from flask import Flask, jsonify

app = Flask(__name__)

@app.route('/')
def homepage():
    time.sleep(1)  # I/O 작업을 동기로 시뮬레이션
    return jsonify({'hello': 'world'})

```

<br>
<br>
<br>
<br>

## B. WSGI vs ASGI 비교

#### ASGI (Asynchronous Server Gateway Interface)
* Python 웹서버와 애플리케이션 사이의 "비동기" 통신 표준
> * WSGI(Web Server Gateway Interface)의 발전형
> * 비동기(Async) + 동기(Sync) 모두 지원
> * HTTP 뿐 아니라 WebSocket, SSE(Server-Sent Events)도 처리 가능
* Python 웹앱과 서버 사이에서 비동기 통신을 가능하게 하는 표준 인터페이스 > FastAPI 고성능 비동기 처리의 핵심

<br>

|구분|WSGI|ASGI|
|---|---|---|
|처리 방식|동기(Synchronous)|비동기(Asynchronous) 지원|
|지원 프로토콜|HTTP 1.1|HTTP 1.1, HTTP/2, WebSocket|
|예|Flask, Django (구버전)|FastAPI, Starlette, Django 3+|
|한계|동시성 처리 불가|다수 클라이언트 요청 처리 가능|

* WSGI는 단일 차선 도로 - 한 번에 한 대만 통과
* ASGI는 멀티레인 고속도로 - 수많은 차량(요청)을 동시 처리

<br>
<br>

### B-1. 요청 처리 흐름 (FastAPI + Uvicorn)
* FastAPI는 Starless 기반이며, Starlette는 ASGI 서버만 지원
> * HTTP 요청 처리 가능
> * WebSocket 지원 가능
> * Background Tasks 처리 가능

```scss
[클라이언트 요청]
      ↓
(Uvicorn - ASGI 서버)
      ↓
Starlette (라우팅, 미들웨어)
      ↓
FastAPI (엔드포인트 실행)
      ↓
[클라이언트 응답]
```
* Uvicorn = ASGI 서버 역할
* FastAPI는 ASGI 애플리케이션 역할

<br>
<br>

### B-2. 코드로 보는 ASGI 앱
* ASGI 애플리케이션은 기본적으로 다음과 같이 동작

```python
async def app(scope, receive, send):
    assert scope["type"] == "http"

    await send({
        "type": "http.response.start",
        "status": 200,
        "headers": [
            [b"content-type", b"text/plain"]
        ]
    })
    await send({
        "type": "http.response.body",
        "body": b"Hello, ASGI World!",
    })

```
* `scope`: 요청 정보 (메서드, 경로 등)
* `recive`: 클라이언트 메시지 받기
* `send`: 클라이언트로 메시지 보내기

* I/O Bound 비동기 처리 실습 코드

```python
import httpx
from fastapi import FastAPI

app = FastAPI()

@app.get("/async-data")
async def fetch_data():
    async with httpx.AsyncClient() as client:
        response = await client.get("https://httpbin.org/get")
        return response.json()
```

<br>
<br>

### B-3. ASGI 주요 특징

|특징|설명|
|---|---|
|비동기 지원|async/await로 수천 개 요청 동시에 처리|
|멀티프로토콜 지원|HTTP, WebSocket, SSE 처리 가능|
|이벤트 기반 아키텍처|요청-응답 뿐 아니라 장기 연결 지원|
|빠른 처리 속도|Starlette, FastAPI, Django Channels 사용|

<br>
<br>

### B-4. ASGI 서버 종류

|서버|특징|
|---|---|
|Uvicorn|가볍고 빠른 ASGI 서버|
|Daphne|Django Channels에서 사용|
|Hypercorn|HTTP/2, WebSocket 지원 강화|

<br>
<br>
<br>
<br>

## C. Pydantic = 초고속 데이터 검증기

* 데이터 파싱과 검증 담당

* JSON → Python 객체로 변환
* 타입 검사 및 유효성 검증
* 기본값, 형 변환, 필드 검증

<br>

### C-1. 빠른 이유
1. Cython 최적화
> * 내부에서 CPython/Cython으로 처리
> * Python의 순수 dict parsing보다 훨씬 빠른

2. 타입 힌트 사용
> * Python 타입 힌트를 활용해 동적 검증 로직 제거
> * 컴파일 타임에 데이터 유효성 규칙 준지

3. Lazy Validation
> * 요청이 올 때 필요한 만큼만 검증

<br>

### C-2. 예제: 데이터 파싱 속도

```python
from pydantic import BaseModel

class User(BaseModel):
    id: int
    name: str
    email: str

# id를 int로 자동 변환하고 검증까지 수행
u = User(id="1", name="Alice", email="alice@example.com")
```

* 위와 같은 변환을 Flask에서는 수동으로 해야 함
* Pydantic은 10배 이상 빠르게 처리 가능

<br>
<br>
<br>
<br>

## D. Pydantic 심화
* `Field` : 요청 데이터에서 각 필드의 제약 조건 정의
* `validator`로 커스텀 검증 : 한 필드 또는 여러 필드 간 검증 로직 추가 시 사용
* `Nested` 모델 (중첩 스키마) : 요청 JSON이 중첩된 구조인 경우, 모델 안에 모델로 처리

<br>

|기능|예제|설명|
|---|---|---|
|Field 옵션|`Field(..., gt=0, max_length=50)`|필드 단위 유효성 검증, Swagger 문서화 반영|
|@validator|커스텀 로직 구현|한 필드 또는 여러 필드 간 검증 로직 추가|
|Nested 모델|모델 안에 모델 정의|중첩 JSON 구조 대응|

<br>
<br>

### D-1. Field
* 매개변수

|옵션|설명|
|---|---|
|`...`|필수 필드 표시(required)|
|`title`|Swagger 문서에 필드 제목으로 표시|
|`description`|Swagger 문서에 필드 설명 추가|
|`max_length`|문자열 최대 길이|
|`gt`,`ge`|숫자 > (greater than), >= (greater equal)|
|`lt`,`le`|숫자 < (lower than), <= (lower equal)|
|`default`|기본값 지정|

<br>

### D-2. 예제 코드
```python
from fastapi import FastAPI
from pydantic import BaseModel, Field

app = FastAPI()

class Item(BaseModel):
    name: str = Field(..., title="아이템 이름", max_length=50)
    price: float = Field(..., gt=0, description="가격은 0보다 커야 함")
    quantity: int = Field(default=1, ge=1, le=100, description="1~100 사이")

@app.post("/items/")
def create_item(item: Item):
    return item
```

<br>

* 정상 요청
```json
POST /items/
{
    "name": "FastAPI 초보 탈출",
    "price": 9.99,
    "quantity": 10
}
```

<br>

* 잘못된 요청
```json
POST /items/
{
    "name": "이름이 매우매우매우매우매우매우 길다aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa",
    "price": -1,
    "quantity": 101
}
```

<br>

* 응답
```json
{
    "detail": [
        {"loc": ["body", "name"], "msg": "ensure this value has at most 50 characters", "type": "value_error.any_str.max_length"},
        {"loc": ["body", "price"], "msg": "ensure this value is greater than 0", "type": "value_error.number.not_gt"},
        {"loc": ["body", "quantity"], "msg": "ensure this value is less than or equal to 100", "type": "value_error.number.not_le"}
    ]
}
```

<br>
<br>

### D-3. `@validator`로 커스텀 검증
```python
from pydantic import BaseModel, validator

class User(BaseModel):
    username: str
    email: str

    @validator("email")
    def validate_email(cls, v):
        if "@" not in v:
            raise ValueError("유효하지 않은 이메일 형식입니다.")
        return v

@app.post("/users/")
def create_user(user: User):
    return user
```

<br>

* 정상 요청
```json
POST /users/
{
    "username": "junedev",
    "email": "june@example.com"
}
```

<br>

* 잘못된 요청
```json
POST /users/
{
    "username": "junedev",
    "email": "not-an-email"
}
```

<br>

* 응답
```json
{
    "detail": [
        {"loc": ["body", "email"], "msg": "유효하지 않은 이메일 형식입니다.", "type": "value_error"}
    ]
}
```

<br>

* 고급: 여러 필드 의존 검증
```python
class Product(BaseModel):
    price: float
    discount: float

    @validator("discount")
    def discount_must_be_less_than_price(cls, v, values):
        if "price" in values and v >= values["price"]:
            raise ValueError("할인은 가격보다 작아야 합니다.")
        return v
```

<br>
<br>

### D-4. Nested 모델 (중첩 스키마)
### 예제 코드
```python
class Address(BaseModel):
    street: str
    city: str
    zipcode: str = Field(..., regex="^\d{5}$")

class Order(BaseModel):
    item_name: str
    quantity: int = Field(..., gt=0)
    shipping_address: Address

@app.post("/orders/")
def create_order(order: Order):
    return order
```

<br>

* 정상 요청
```json
POST /orders/
{
    "item_name": "FastAPI 교재",
    "quantity": 2,
    "shipping_address": {
        "street": "중앙로 123",
        "city": "서울",
        "zipcode": "12345"
    }
}
```

<br>

* 잘못된 요청
```json
POST /orders/
{
    "item_name": "FastAPI 교재",
    "quantity": 0,
    "shipping_address": {
        "street": "중앙로 123",
        "city": "서울",
        "zipcode": "abcde"
    }
}
```

<br>

* 응답
```json
{
    "detail": [
        {"loc": ["body", "quantity"], "msg": "ensure this value is greater than 0", "type": "value_error.number.not_gt"},
        {"loc": ["body", "shipping_address", "zipcode"], "msg": "string does not match regex \"^\\d{5}$\"", "type": "value_error.str.regex"}
    ]
}
```

<br>
<br>
<br>
<br>

## E. FastAPI의 요청 처리 순서
```
클라이언트 요청
   ↓
ASGI 서버(Uvicorn)
   ↓
Starlette가 요청 처리
   ↓
FastAPI 라우터에서 경로 매칭
   ↓
Pydantic으로 요청 데이터 검증 & 파싱
   ↓
엔드포인트 함수 호출 (sync/async)
   ↓
Pydantic으로 응답 데이터 검증
   ↓
ASGI 서버가 응답 반환
```
* Pydantic이 요청/응답 검증 담당
* Starlette가 라우팅/미들웨어/비동기 처리 담당
> 요청의 모든 과정이 타입 안전 + 비동기 최적화 되어 있는 구조

<br>
<br>
<br>
<br>

## F. 요약: Node.js / Go와 대등한 성능
* FastAPI = Starlette(비동기) + Pydantic(데이터 검증)의 조합
* 단순 JSON API라면 Node.js, Go와 동급 처리량
* I/O bound 작업(DB, 외부 API 호출 등)에서 특히 강력
* 단점: Python 자체가 GIL 때문에 CPU bound 작업은 Go보다 느림

<br>

|요소|FastAPI|
|---|---|
|요청 처리 엔진|Starlette (ASGI 기반 초경량 비동기 프레임워크)|
|데이터 검증|Pydantic (Cython 최적화된 초고속 파서)|
|장점|Node.js/Go에 맞먹는 I/O 처리 성능|
|한계|CPU 연산 많을 땐 Go가 여전히 우위|
