# 07. Python과 async

* `async def`: 비동기 함수 (코루틴) 정의
* `await`: 다른 비동기 함수 실행을 기다리고, 그동안 다른 작업이 실행되도록 제어권을 넘겨줌
* `asyncio.run()`: 비동기 함수 실행
* 장점: I/O 작업(네트워크, 파일 입출력 등)의 대기 시간을 활용하여 효율적인 동시성(Concurrency) 달성

<br>
<br>
<br>
<br>

## A. `async def`
* 코루틴(Coroutine)을 정의하는 키워드
> **비동기 함수를 만든다는 의미**
* 호출 시 코루틴 객체를 반환하며 즉시 실행되지 않음
> 일반 함수처럼 실행되지 않으며 `coroutine` 객체 반환

<br>

```python
async def fetch_data():
    return "data"
```

<br>
<br>
<br>
<br>

## B. `await`
* 코루틴 실행을 시작하고 완료될 때까지 대기
* 반드시 `async def` 메서드 안에서만 사용 가능
* 핵심
> * `await`을 만나면 `async def` 함수의 실행 흐름이 잠시 멈춤
> * 이벤트 루프(Python)는 다른 일을 할 수 있도록 제어권을 넘겨줌
> * **프로그램 전체가 멈추는 것이 아님**

<br>

```python
async def main():
    data = await fetch_data()
    print(data)
```

<br>
<br>
<br>
<br>

## C. 비동기 함수의 실행: `asyncio.run()`
* 비동기 코드 실행을 위한 "진입점" 또는 "시동기"
> * 비동기 함수(`async def`)는 직접 실행 불가하며, 이벤트 루프 필요
> * Python 3.7 이상에서는 `asyncio.run()` 사용
* 최상위 비동기 함수를 이벤트 루프 위에서 실행 시킴

<br>

```python
import asyncio

async def fetch_data():
    print("데이터 가져오는 중...")
    await asyncio.sleep(2)   # 2초 동안 기다림 (비동기적으로)
    return "data"

async def main():
    result = await fetch_data()
    print("결과:", result)

asyncio.run(main())
```

* 출력

```scss
데이터 가져오는 중...
(2초 후)
결과: data
```

<br>
<br>
<br>
<br>

## D. 동시 실행 (Concurrency) vs 병렬 처리 (Parallelism)
* 동시성 (Concurrency)
> * `asyncio.gather()` 등을 사용해 여러 작업을 **번갈아 가며** 처리
> * 싱글 스레드에서 실행되므로, 한 번에 하나의 작업만 실제로 처리 됨

* 병렬 처리 (Parallelism)
> * `multiprocessing` 등을 사용해 여러 작업을 여러 CPU 코어에서 동시 처리

* 정리
> * `asyncio`는 동시성을 위한 도구로, 병렬 처리를 위한 도구가 아님
> * 때문에 CPU를 많이 사용하는 계산 작업(CPU-bound)에는 효과가 없음
> * 이와 같은 계산 작업이 이벤트 루프를 차지해 버리면, 다른 모든 비동기 작업이 멈춰버려서 asyncio의 장점이 사라짐

|분류|설명|방법|
|---|---|---|
|I/O-bound 작업|네트워크, 디스크 읽기/쓰기|`asyncio` 최적|
|CPU-bound 작업|복잡한 수학 계산, 데이터 처리|multiprocessing 이나 concurrent.futures.ProcessPoolExecutor 고려|


<br>
<br>

### D-1. 작업 동시 실행: `gather` vs `create_task`

* `asyncio.create_task(코루틴)`
> * `"백그라운드에서 이 작업 바로 시작해!"`
>> * 코루틴을 즉시 이벤트 루프에 예약
>> * 해당 작업을 추적할 수 있는 Task 객체 바로 반환 (논블로킹)
> * 작업을 시작만 시켜놓고, 현재 함수는 다른 일을 계속 진행할 수 있음

```python
async def main():
    # task1을 백그라운드에서 즉시 실행 시작
    task1 = asyncio.create_task(task("작업1", 2))
    # task2를 백그라운드에서 즉시 실행 시작
    task2 = asyncio.create_task(task("작업2", 1))

    print("다른 작업 수행 중...")

    # 두 작업이 모두 끝날 때까지 기다림
    await task1
    await task2
    print("모든 작업 완료")
```

<br>

* `asyncio.gather(코루틴1, 코루틴2, ...)`
> * `"여기 있는 작업들 전부 동시에 실행하고, 모두 끝날 때까지 기다렸다가 결과를 한 번에 줘!"`
>> * 여러 코루틴 동시 실행
>> * 모든 작업이 완료되면 그 결과들을 리스트로 묶어 반환

```python
import asyncio

async def task(name, sec):
    print(f"{name} 시작")
    await asyncio.sleep(sec)
    print(f"{name} 끝")
    return name

async def main():
    results = await asyncio.gather(
        task("작업1", 2),
        task("작업2", 1)
    )
    print("모든 작업 완료:", results)

asyncio.run(main())
```

* 출력

```scss
작업1 시작
작업2 시작
(1초 후)
작업2 끝
(2초 후)
작업1 끝
모든 작업 완료: ['작업1', '작업2']
```

<br>
<br>
<br>
<br>

## E. 비동기 반복자 `async for`
* for 루프의 비동기 버전
* 스트리밍 데이터처럼, 다음 항목을 가져오는 데 시간이 걸리는(I/O 대기가 필요한) 대상 순회 시 사용

```python
async def stream_llm_response():
    for i in range(3):
        await asyncio.sleep(1)  # 네트워크로 다음 데이터 조각을 기다리는 것을 흉내
        yield f"응답 조각 {i}"

async def main():
    # stream_llm_response()가 생성하는 비동기 스트림을 하나씩 처리
    async for chunk in stream_llm_response():
        print(chunk)

asyncio.run(main())

# 출력:
# (1초 후) 응답 조각 0
# (1초 후) 응답 조각 1
# (1초 후) 응답 조각 2
```

<br>
<br>
<br>
<br>

## F. 비동기 컨텍스트 관리자 `async with`
* with 문의 비동기 버전
* 자원의 연결(setup)과 해제(teardown) 과정이 비동기 I/O를 필요로 할 때 사용
> * 예: 비동기 데이터베이스 접속 및 종료

```python
class AsyncDBConnection:
    async def __aenter__(self): # 'async def'로 정의
        print("DB 연결 시작...")
        await asyncio.sleep(1)
        print("DB 연결 성공!")
        return self

    async def __aexit__(self, exc_type, exc, tb): # 'async def'로 정의
        print("DB 연결 해제 시작...")
        await asyncio.sleep(1)
        print("DB 연결 해제 성공!")
   
async def main():
    async with AsyncDBConnection() as conn:
        print("DB 작업 수행...")
    
asyncio.run(main())
```
