# 07. Python과 async

* `async def`: 비동기 함수(코루틴) 정의
* `await`: 다른 비동기 함수를 호출하고 결과를 기다림
* 실행 시: `asyncio.run()` 사용
* 장점: I/O 작업(네트워크, 파일 입출력 등) 대기 시간 동안 CPU가 다른 작업을 처리 가능 → 효율적인 동시성 처리

<br>
<br>

### A. `async`
* 코루틴(coroutine)을 정의하는 함수 앞에 붙음
* **비동기 함수를 만든다는 뜻**

```python
async def fetch_data():
    return "data"
```

> * 해당 함수는 일반 함수처럼 실행되지 않고, `coroutine` 객체 반환

<br>
<br>

### B. `await`
* 비동기 함수(coroutine)를 실행할 때 사용
* 코루틴의 실행이 완료될 때까지 잠깐 멈췄다가 결과 반환
* > * `async def` 함수의 실행 흐름만 잠시 멈추고, 이벤트 루프(Python)는 다른 일을 할 수 있도록 제어권을 넘겨준다
* 반드시 `async` 함수 안에서만 사용 가능

```python
async def main():
    data = await fetch_data()
    print(data)
```

<br>
<br>

### C. 실행 방법
* 비동기 함수(`async def`)는 직접 실행할 수 없고, 이벤트 루프 필요
* Python 3.7 이상에서는 `asyncio.run()` 주로 사용

```python
import asyncio

async def fetch_data():
    print("데이터 가져오는 중...")
    await asyncio.sleep(2)   # 2초 동안 기다림 (비동기적으로)
    return "data"

async def main():
    result = await fetch_data()
    print("결과:", result)

asyncio.run(main())
```

* 출력

```scss
데이터 가져오는 중...
(2초 후)
결과: data
```

<br>
<br>

### D. 동시 실행 **(병렬 아님)**
* 여러 개의 코루틴을 동시에 실행하고 싶다면 `asyncio.gather()` 사용

```python
import asyncio

async def task(name, sec):
    print(f"{name} 시작")
    await asyncio.sleep(sec)
    print(f"{name} 끝")
    return name

async def main():
    results = await asyncio.gather(
        task("작업1", 2),
        task("작업2", 1)
    )
    print("모든 작업 완료:", results)

asyncio.run(main())
```

* 출력

```scss
작업1 시작
작업2 시작
(1초 후)
작업2 끝
(2초 후)
작업1 끝
모든 작업 완료: ['작업1', '작업2']
```

* 동시 실행은 병렬이 아님 → CPU 연산은 병렬이 되지 않음!
> * `asyncio`는 단일 스레드 기반 동시성 → **CPU 바운드 작업에는 효과 없음**

```python
# 잘 안 되는 예시
async def cpu_heavy():
    sum(i*i for i in range(10**7))  # CPU 바운드
    return "done"
```

* 이런 경우 `asyncio` 대신 `concurrent.futures` 나 `multiprocessing` 필요

<br>
<br>

### E. `asyncio.gather()` 와 `asyncio.create_task()`의 차이
* 둘 다 동시 실행하지만, `create_task()`는 백그라운드 태스크 등록 느낌이 있다
