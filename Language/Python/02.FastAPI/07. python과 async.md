# 07. Python과 async

* `async def`: 비동기 함수 (코루틴) 정의
* `await`: 다른 비동기 함수 실행을 기다리고, 그동안 다른 작업이 실행되도록 제어권을 넘겨줌
* `asyncio.run()`: 비동기 함수 실행
* 장점: I/O 작업(네트워크, 파일 입출력 등)의 대기 시간을 활용하여 효율적인 동시성(Concurrency) 달성

<br>
<br>
<br>

## A. `async def`
* 코루틴(Coroutine)을 정의하는 키워드
> **비동기 함수를 만든다는 의미**
* 호출 시 코루틴 객체를 반환하며 즉시 실행되지 않음
> 일반 함수처럼 실행되지 않으며 `coroutine` 객체 반환

<br>

```python
async def fetch_data():
    return "data"
```

<br>
<br>
<br>

## B. `await`
* 코루틴 실행을 시작하고 완료될 때까지 대기
* 반드시 `async def` 메서드 안에서만 사용 가능
* 핵심
> * `await`을 만나면 `async def` 함수의 실행 흐름이 잠시 멈춤
> * 이벤트 루프(Python)는 다른 일을 할 수 있도록 제어권을 넘겨줌
> * **프로그램 전체가 멈추는 것이 아님**

<br>

```python
async def main():
    data = await fetch_data()
    print(data)
```

<br>
<br>
<br>

## C. 비동기 함수의 실행: `asyncio.run()`
* 비동기 코드 실행을 위한 "진입점" 또는 "시동기"
> * 비동기 함수(`async def`)는 직접 실행 불가하며, 이벤트 루프 필요
> * Python 3.7 이상에서는 `asyncio.run()` 사용
* 최상위 비동기 함수를 이벤트 루프 위에서 실행 시킴

<br>

```python
import asyncio

async def fetch_data():
    print("데이터 가져오는 중...")
    await asyncio.sleep(2)   # 2초 동안 기다림 (비동기적으로)
    return "data"

async def main():
    result = await fetch_data()
    print("결과:", result)

asyncio.run(main())
```

* 출력

```scss
데이터 가져오는 중...
(2초 후)
결과: data
```

<br>

* Jupyter notebook은 `asyncio`를 사용하지 않고 바로 사용 가능
> * Jupyter/IPython은 이벤트 루프가 이미 돌고 있기 때문
> * 때문에 `asyncio.run()`을 사용 시 에러 발생
> * 그냥 `await` 바로 사용 가능

```python
await main()
```

<br>
<br>
<br>

## D. 동시 실행 (Concurrency) vs 병렬 처리 (Parallelism)
* 동시성 (Concurrency)
> * `asyncio.gather()` 등을 사용해 여러 작업을 **번갈아 가며** 처리
> * 싱글 스레드에서 실행되므로, 한 번에 하나의 작업만 실제로 처리 됨

* 병렬 처리 (Parallelism)
> * `multiprocessing` 등을 사용해 여러 작업을 여러 CPU 코어에서 동시 처리

* 정리
> * `asyncio`는 동시성을 위한 도구로, 병렬 처리를 위한 도구가 아님
> * 때문에 CPU를 많이 사용하는 계산 작업(CPU-bound)에는 효과가 없음
> * 이와 같은 계산 작업이 이벤트 루프를 차지해 버리면, 다른 모든 비동기 작업이 멈춰버려서 asyncio의 장점이 사라짐

|분류|설명|방법|
|---|---|---|
|I/O-bound 작업|네트워크, 디스크 읽기/쓰기|`asyncio` 최적|
|CPU-bound 작업|복잡한 수학 계산, 데이터 처리|multiprocessing 이나 concurrent.futures.ProcessPoolExecutor 고려|


<br>
<br>

### D-1. 작업 동시 실행: `gather` vs `create_task`

* `asyncio.create_task(코루틴)`
> * `"백그라운드에서 이 작업 바로 시작해!"`
>> * 코루틴을 즉시 이벤트 루프에 예약
>> * 해당 작업을 추적할 수 있는 Task 객체 바로 반환 (논블로킹)
> * 작업을 시작만 시켜놓고, 현재 함수는 다른 일을 계속 진행할 수 있음

```python
async def main():
    # task1을 백그라운드에서 즉시 실행 시작
    task1 = asyncio.create_task(task("작업1", 2))
    # task2를 백그라운드에서 즉시 실행 시작
    task2 = asyncio.create_task(task("작업2", 1))

    print("다른 작업 수행 중...")

    # 두 작업이 모두 끝날 때까지 기다림
    await task1
    await task2
    print("모든 작업 완료")
```

<br>

* `asyncio.gather(코루틴1, 코루틴2, ...)`
> * `"여기 있는 작업들 전부 동시에 실행하고, 모두 끝날 때까지 기다렸다가 결과를 한 번에 줘!"`
>> * 여러 코루틴 동시 실행
>> * 모든 작업이 완료되면 그 결과들을 리스트로 묶어 반환

```python
import asyncio

async def task(name, sec):
    print(f"{name} 시작")
    await asyncio.sleep(sec)
    print(f"{name} 끝")
    return name

async def main():
    results = await asyncio.gather(
        task("작업1", 2),
        task("작업2", 1)
    )
    print("모든 작업 완료:", results)

asyncio.run(main())
```

* 출력

```scss
작업1 시작
작업2 시작
(1초 후)
작업2 끝
(2초 후)
작업1 끝
모든 작업 완료: ['작업1', '작업2']
```

<br>
<br>
<br>

## E. 비동기 반복자 `async for`
* for 루프의 비동기 버전
* 스트리밍 데이터처럼, 다음 항목을 가져오는 데 시간이 걸리는(I/O 대기가 필요한) 대상 순회 시 사용

```python
async def stream_llm_response():
    for i in range(3):
        await asyncio.sleep(1)  # 네트워크로 다음 데이터 조각을 기다리는 것을 흉내
        yield f"응답 조각 {i}"

async def main():
    # stream_llm_response()가 생성하는 비동기 스트림을 하나씩 처리
    async for chunk in stream_llm_response():
        print(chunk)

asyncio.run(main())

# 출력:
# (1초 후) 응답 조각 0
# (1초 후) 응답 조각 1
# (1초 후) 응답 조각 2
```

<br>
<br>
<br>

## F. 비동기 컨텍스트 관리자 `async with`
* with 문의 비동기 버전
* 자원의 연결(setup)과 해제(teardown) 과정이 비동기 I/O를 필요로 할 때 사용
> * 예: 비동기 데이터베이스 접속 및 종료

```python
class AsyncDBConnection:
    async def __aenter__(self): # 'async def'로 정의
        print("DB 연결 시작...")
        await asyncio.sleep(1)
        print("DB 연결 성공!")
        return self

    async def __aexit__(self, exc_type, exc, tb): # 'async def'로 정의
        print("DB 연결 해제 시작...")
        await asyncio.sleep(1)
        print("DB 연결 해제 성공!")
   
async def main():
    async with AsyncDBConnection() as conn:
        print("DB 작업 수행...")
    
asyncio.run(main())
```

<br>
<br>
<br>

## G. 일반 함수 (`def`)와 동기 함수(`async def`)의 차이

### G.1. 일반 함수 (`def`): 자판기
* 일반 함수는 자판기와 같음
> * 호출: 돈을 넣음 (`my_function()`)
> * 결과: 즉시 음료수가 나옴 (`return value`)

```python
def make_juice():
    print("주스를 즉시 만듭니다.")
    return "오렌지 주스"

# 자판기처럼 즉시 결과가 나옴
juice = make_juice()
print(juice) # "오렌지 주스"
```

<br>
<br>

### G.2. 비동기 함수 (`async def`): 케이크 레시피
* `async def`로 만든 함수 (정확히는 코루틴)는 "케이크" 자체가 아니라, "케이크를 만드는 방법이 적힌 레시피"와 같음
> * 그냥 호출: `async def` 함수를 가능 호출하는 것은, 요리책에서 레시피 페이지만 찢어 손에 든 것과 같다!
> * 당연히 케이크는 반환되지 않으며, 그냥 레시피 종이(코루틴 객체)만 반환됨

```python
async def bake_cake():
    print("케이크를 굽기 시작합니다... (시간이 걸림)")
    await asyncio.sleep(1)  # 오븐에서 굽는 시간 (I/O 작업 비유)
    return "초콜릿 케이크"

# 레시피만 얻음 (케이크가 아님!)
recipe = bake_cake()
print(recipe) # <coroutine object bake_cake at 0x...> -> "코루틴 객체(레시피)"가 출력됨
```

<br>
<br>

### G.3. `await` 키워드: "레시피대로 요리해!"
* `await`는 "자, 이제 이 레시피를 보고 실제로 요리를 시작해!"라는 실행 명령어!
> * `await`로 호출: `await` 키워드를 붙여 레시피를 실행하면!
> * 비로소 요리(시간이 걸리는 작업)가 시작되고, 요리가 끝난 뒤에야 최종 결과물인 케이크를 얻을 수 있음

```python
# 'await'를 붙여야만 레시피대로 요리를 시작하고, 케이크를 얻을 수 있음
# (단, 이 코드는 반드시 다른 async def 함수 안에서 실행되어야 함)

cake = await bake_cake()
print(cake) # "초콜릿 케이크"
```

<br>
<br>

### G.4. `async def` 블록: "주방"
* `await` (요리 행위)는 아무데서나 할 수 없음
> * 반드시 오븐과 조리도구가 갖춰진 "주방" 안에서만 할 수 있음
* Python에서 이 "주방"의 역할을 하는 것이 바로 `async def`로 선언된 함수 블록임

<br>

#### `async`의 규칙
1. `async def`로 만든 것은 "레시피"
2. 이 "레시피"를 실행해서 결과를 얻으려면 반드시 `await`를 붙여야 함
> * `async def`로 정의된 메서드를 실행하려면 `await`가 반드시 필요!
3. `await`라는 행위는 반드시 `async def`라는 "주방" 안에서만 할 수 있음
4. 이 모든 것을 시작하려면, `asyncio.run()`이나 주피터 노트북의 `await`처럼 최초의 "주방"을 가동시켜줄 무언가가 필요!

